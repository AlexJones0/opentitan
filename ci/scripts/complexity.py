#!/usr/bin/env python3
import tabulate
import subprocess
import argparse
import sys
import matplotlib.pyplot as plt

#SCC_PATH = "/home/alexj/misc/scc/scc"

if __name__ == "__main__":
    desc = "A python script to check the code complexity of files within the repository."
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument("ftypes",
                        metavar="ftypes",
                        nargs='*',
                        default=[],
                        help="Filetypes to include, e.g. 'Markdown' or 'CSV'. Includes all by default.")
    parser.add_argument("-p", "--path_limit",
                        default=50,
                        type=int,
                        help="Formats file names and paths longer than this length to a maximum specified length. Defaults to 50")
    parser.add_argument("-s", "--sort",
                        default="Complexity Per Line",
                        type=str,
                        help="The column field to sort by [language, location, filename, lines, code, comments, blanks, complexity, bytes, complexity per line].")
    parser.add_argument("-r", "--reverse",
                        action="store_true",
                        help="Adding this option will display the result in ascending order, instead of descending.")
    parser.add_argument("-m", "--min_code",
                        default=0,
                        type=int,
                        help="The minimum number of lines of code (not includding blanks/comments) to not be filtered. Defaults to 0.")
    parser.add_argument("-g", "--graph",
                        default=0,
                        type=int,
                        help="The top number of elements to include in a graph. 0 elements means that a graph will not be generated.")
    parser.add_argument("-z", "--scc_path",
                        default="scc",
                        type=str,
                        help="The path to the SCC binary to use in calculating code complexity. Can be used to provide a custom binary (e.g. that incorporates Myers' Interval).")
    parser.add_argument
    options = parser.parse_args()
    options.ftypes = [type_.lower().strip() for type_ in options.ftypes]
    EXCLUDE_TYPES = ["FORTRAN Legacy", "Emacs Lisp", "Prolog"]
    assert options.path_limit > 3, "path limit must be bigger than 3!"

    # TODO scc dependency
    complexity_csv = subprocess.check_output("""
        rgrep -L "generated by" \
        | grep -v -E "__pycache__|.mypy_cache|autogen|/vendor/" \
        | xargs {} --no-gen -z --no-min-gen --sort complexity --by-file --format csv
        """.format(options.scc_path), 
        shell=True)
    complexity_csv = [
        line.strip().split(",")
        for line in complexity_csv.decode("utf-8").splitlines() 
        if len(line.strip()) != 0
    ]
    header = complexity_csv[0] + ["Complexity Per Line"]
    try:
        sort_field = [field.lower().strip() for field in header].index(options.sort.lower())
    except ValueError:
        print(f"Unknown field {options.sort.lower()}. Availble fields: {[field.lower().strip() for field in header]}")
        sys.exit()
    complexity_csv = [
        line + [str(round(float(line[7]) / float(line[4]), 5))]
        for line in complexity_csv
        if line[7] != "Complexity" and float(line[4]) != 0
        and line[0] not in EXCLUDE_TYPES
        and int(line[4]) >= options.min_code
    ]
    complexity_csv = [
        [line[0], 
         "..." + line[1][-(options.path_limit-3):] if len(line[1]) > options.path_limit else line[1],
         "..." + line[2][-(options.path_limit-3):] if len(line[2]) > options.path_limit else line[2]
        ] + line[3:]
        for line in complexity_csv
    ]
    if len(options.ftypes) > 0:
        complexity_csv = [
            line for line in complexity_csv
            if line[0].lower().strip() in options.ftypes
            or any([
                line[1].lower().strip().endswith(ftype)
                for ftype in options.ftypes
            ])
        ] 
    complexity_csv = sorted(
        complexity_csv, 
        key=lambda line: float(line[sort_field]), reverse=not options.reverse)
    complexity_csv = [header] + complexity_csv
    print(tabulate.tabulate(complexity_csv))
    
    total_lines = sum([int(line[4]) for line in complexity_csv[1:]])
    total_complexity = sum([int(line[7]) for line in complexity_csv[1:]])
    print(f"\nTotal checked lines: {total_lines}")
    print(f"Total complexity: {total_complexity}")
    print(f"Average code complexity per (checked) line: {total_complexity / total_lines}")

    if options.graph <= 0:
        exit()
    
    if not options.reverse:
        top_files = complexity_csv[1:options.graph+1]
    else:
        top_files = complexity_csv[::-1][:-1][:options.graph][::-1]
    labels = [line[1] for line in top_files]
    values = [float(line[sort_field]) for line in top_files]
    plt.xticks(rotation=55, ha='right')
    plt.bar(labels, values, color='blue', width=0.4)
    plt.xlabel("Source files")
    plt.ylabel(header[sort_field])
    plt.title("OpenTitan source file code complexity")
    plt.show()


